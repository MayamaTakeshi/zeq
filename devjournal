================================================
2017/04/08 takeshi:
Regarding syntax described in string_matching.pegjs, for escaping the string collection syntax '!{a}' originally I was planning to follow escape syntax of js and allow the user to write: '!\{a}'.
However, this will not work as when js sees this, it will process escaping chars and our code will get '!{a}'. So we will not be aware there was intention to escape anything.
Instead, we will establish that to escape the string collection syntax, we must escape the '!' by using '!!'. Ex: '!!{a}'.

================================================
2017/04/08 takeshi:
Here is how matching would be used:

zester.wait([
	{
		source: "some_event_source",
		name: "some_event_name",
		data: m.m({
			a: 1,
			b: 2,
			d: 4,
			data1: {
				aa: 11,
				bb: 22,
				cc: 33,
				dd: 44,
				ee: m.p({
					A: 1,
					B: 2,
					D: 4,
				}), // partial match
			}, // full match
			data2: m.m({
				aaa: 111,
				bbb: 222,
				ddd: 444,
				eee: {
					AA: 11,
					BB: 22,
					CC: 33,
					DD: 44,
				}, // full match	
			}), // partial match
		})
	}
], 1000)

In the above, m.m (matching.match) is a function that returns a fun(expected, received) that checks only for the specified data (partial matching). To do a full matching attempt, passing just a dict is enough (and both full and partial matchers can recursively use full and partial matching).

================================================
2017/04/08 takeshi:
For partial array matching we can use:

const _ = undefined

zester.wait([
	{
		source: "some_event_source",
		name: "some_event_name",
		data: {
			list1: m.m([1]) # check only the first element of the list. The list can have more than one element
			list2: m.m([_,2,3] # check only the second and third elements of the list. The list can have more than three elements
		},
	}
], 1000)

So for both dicts and arrays, m.m() always creates a partial matcher.
In the above, the function generated by m.m() would ignore any value whose place matches undefined (definition of _ as a const to undefined is a convenience but you are not required to use it as the matching would only care about undefined).

(But beware that node cli accepts underscore as an instruction to print the result of the last evaluated expression (http://www.codingdefined.com/2014/06/use-of-underscore-in-nodejs.html))

Also, we should permit string matching:
			list: m.m([
				'element_0'
				`!{scheme}:!{user}@${domain}`,
				'element_2',
				_,
				4,
				'element_5',
			])

If there is actual need to check for the presense of element undefined in the array, we can just pass a special function for this:
			list: m.m([
				0,
				(x) => { return x == undefined },
				2,
			])
and even provide it as a helper function in our module:
			list: m.m([
				0,
				m.undefined,
				2,
			])

This is a small cost to pay as most of the time we will not have to deal with undefined as element in arrays or dicts (it will be supported in case of keys too).


