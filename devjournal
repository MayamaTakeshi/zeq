================================================
2017/04/08 takeshi:
Regarding syntax described in string_matching.pegjs, for escaping the string collection syntax '!{a}' originally I was planning to follow escape syntax of js and allow the user to write: '!\{a}'.
However, this will not work as when js sees this, it will process escaping chars and our code will get '!{a}'. So we will not be aware there was intention to escape anything.
Instead, we will establish that to escape the string collection syntax, we must escape the '!' by using '!!'. Ex: '!!{a}'.

================================================
2017/04/08 takeshi:
Here is how matching would be used:

zester.wait([
  {
    source: "sip",
    name: "incoming",
    data1: {
      a: m.m({
        A: 1,
        B: 2,
        D: 4,
      }), // partial match (element 'C' is ignored)
			b: 2,
    }, // full match
    data2: m.m({
      aa: {
        AA: 1,
        BB: 2,
        CC: 3,
        DD: 4,
      }, // full match 
    }), // partial match (element 'bb' is ignored)
  }
], 1000)

In the above, m.m (matching.match) is a function that returns a fun(expected, received) that checks only for the specified data (partial matching). To do a full matching attempt, passing just a dict is enough (and both full and partial matchers can recursively use full and partial matching).

================================================
2017/04/08 takeshi:
For partial array matching we can use:

const _ = undefined

zester.wait([
	{
		source: "some_event_source",
		name: "some_event_name",
		data: {
			list1: m.m([1]) # check only the first element of the list. The list can have more than one element
			list2: m.m([_,2,3] # check only the second and third elements of the list. The list can have more than three elements
		},
	}
], 1000)

So for both dicts and arrays, m.m() always creates a partial matcher.
In the above, the function generated by m.m() would ignore any value whose place matches undefined (definition of _ as a const to undefined is a convenience but you are not required to use it as the matching would only care about undefined).

(But beware that node cli accepts underscore as an instruction to print the result of the last evaluated expression (http://www.codingdefined.com/2014/06/use-of-underscore-in-nodejs.html))

Also, we should permit string matching:
			list: m.m([
				'element_0'
				`!{scheme}:!{user}@${domain}`,
				'element_2',
				_,
				4,
				'element_5',
			])

If there is actual need to check for the presense of element undefined in the array, we can just pass a special function for this:
			list: m.m([
				0,
				(x) => { return x == undefined },
				2,
			])
and even provide it as a helper function in our module:
			list: m.m([
				0,
				m.undefined,
				2,
			])

This is a small cost to pay as most of the time we will not have to deal with undefined as element in arrays or dicts (it will be supported in case of keys too).

================================================
2017/04/09 takeshi:
We should also be able specify value collection and variable assignment.

Here is a typical http server code:

var http = require('http');
var index = fs.readFileSync('index.html');

http.createServer(function (req, res) {
  res.writeHead(200)
  res.end()
}).listen(8000)


The equivalent code using zester would be:

var zester = require('zester');
var m = require('matching');
var http = require('http');

http.createServer(zester.cb_interceptor('http', 'request')).listen(8000);

zester.wait([
	{
		source: 'http',
		name: 'request',
		args: [m.collect('req'), m.collect('res')],
	}
], 1000)

zester.exec('process http request', () => {
	res.writeHead(200)
	res.end(200)
})
			
In the above, zester.cb_interceptor is used to catch callbacks that happen in the http server and enqueue them for later processing.
Then in the zester.wait we collect and assign the variables req and res to permit later processing with zester.exec.

================================================
2017/04/09 takeshi:
We should also be able to specify value collection and variable assignment.

Thinking again, zest.wait itself implies matches:

zester.wait([
	{
		source: 'XXX'
		name: 'YYY',
		data: 'ZZZ',
	},
], 1000)

So, we will always to partial match for both dicts and arrays.
Then if some user needs full match, we can define a function full match that would required an exact match:
	m.full(expected)

================================================
2017/04/09 takeshi:
We must also ensure that any access to non existent keys in our modules throw an error. Otherwise, we will fail in case of typos. Ex:
  key: m.absente
instead of:
  key: m.absent

================================================
2017/12/01 takeshi:

To run unit tests:
  node_modules/jest/bin/jest.js

To run sample tests:
  node samples/FILE_NAME
Ex:
  node samples/zester_test.js
  node samples/fs_test.js


For reference, node version used: v7.10.0

================================================
2017/12/04 takeshi:

Module string_matching was moved to https://github.com/MayamaTakeshi/string-matching


================================================
2017/12/04 takeshi:

Module matching was moved to https://github.com/MayamaTakeshi/data-matching


